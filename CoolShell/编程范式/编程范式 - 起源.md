# 编程范式 - 起源

[原文](https://time.geekbang.org/column/article/301)

**泛型编程**
讨论了从 C 到 C++ 的泛型编程方法，并系统地总结了编程语言中的类型系统和泛型编程的本质

**函数式编程**
讲述了函数式编程用到的技术，及其思维方式，并通过 Python 和 Go 修饰器的例子，展示了函数式编程下的代码扩展能力，以及函数的相互和随意拼装带来的好处。

**面向对象编程**
讲述与传统的编程思想相反，面向对象设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，列举了面向对象编程的优缺点，基于原型的编程范式，以及 Go 语言的委托模式。

**编程本质与逻辑编程**
先探讨了编程的本质：逻辑部分才是真正有意义的，控制部分只能影响逻辑部分的效率，然后结合 Prolog 语言介绍了逻辑编程范式，最后对程序世界里的编程范式进行了总结，对比了它们之间的不同。


**什么是编程范式**
编程范式的英语是 programming paradigm，范即模范之意，范式即模式、方法，是一类典型的编程风格，是指从事软件工程的一类典型的风格

## 先从 C 语言开始

> 因为 C 语言历史悠久，而几乎现在看到的所有编程语言都是以 C 语言为基础来拓展的，不管是 C++、Java、C#、Go、Python、PHP、Perl、JavaScript、Lua，还是 Shell。

**C语言特性**
- C语言是一个静态弱类型的语言，在使用变量时需要声明变量类型，但是类型间可以隐式转换。
- 不同的变量类型可以用结构体(struct)组合在一起，以此来声明新的数据类型
- C语言可以使用 `typedef` 关键字来定义类型别名，以此来达到变量类型的抽象
- C语言是一个有结构化程序设计、具有变量作用域以及递归功能的过程式语言
- C语言传递参数一般是以值传递，也可以传递指针
- 通过指针，C语言可以容易地对内存进行低级控制，然而这引入了非常大的编程复杂度
- 编译预处理让C语言的编译更具有弹性，比如跨平台

> C语言的这些特性，可以让程序员在微观层写出非常精细和精确的编程操作，让程序员可以在
底层和系统细节上非常自由、灵活和精准地控制代码。然而，在代码组织和功能编程上，C语言的上述特性，却不那么美妙

## 从 C 语言的一个简单例子说起

```C
void swap(int* x, int* y)
{
    int temp = *x;
    *x = *y;
    *y = tmp;
}
```
> 这里为什么要传指针？这里是 C 语言指针，因为如果你不用指针的话，那么参数变成传值，即函数的形参是调用实参的一个拷贝，函数里面对形参的修改无法影响实参的结果。为了要达到调用完函数后，实参内容的交换，必须要把实参的地址传递进来，也就是传指针。这样在函数里面做交换，实际变量的值也被交换了。

> **这个函数最大的问题就是它只能给 int 值用，这个世界上还有很多类型包括 double、float，这就是静态语言最糟糕的一个问题**

### 数据类型与现实世界的类比

无论是传统世界，还是编程世界，我们都在干一件事情，什么事呢？ **那就是通过使用一种更为通用的方式，用另外的话说就是抽象和隔离，让复杂的“世界”变得简单一些。**

**然而，要做到抽象，对于 C 语言这样的类型语言来说，首当其冲的就是抽象类型，这就是所谓的——泛型编程。**

C语言的类型转换，有时会带来很多问题

比如：一个 double a[10] 的数组，a[2] 意味着 a + sizeof(double) * 2。如果你把 a 强转成 int，那么 a[2] 就意味着 a + sizeof(int) * 2。我们知道 sizeof(double) 是 8，而 sizeof(int) 是 4。于是访问到了不同的地址和内存空间，这就导致程序出现严重的问题。

## C 语言的泛型

C 语言的类型泛型基本上来说就是使用`void *`关键字或是使用宏定义

```C
void swap(void* x, void* y, size_t size)
{
     char tmp[size];
     memcpy(tmp, y, size);
     memcpy(y, x, size);
     memcpy(x, tmp, size);
}
```
这个实现方式有三个重点
- 函数接口中增加了一个size参数。因为，用了 void* 后，类型被“抽象”掉了，编译器不能通过类型得到类型的尺寸了，所以，需要我们手动地加上一个类型长度的标识。
- 函数的实现中使用了`memcpy()`函数。还是因为类型被“抽象”掉了，所以不能用赋值表达式了，很有可能传进来的参数类型还是一个结构体，因此，为了要交换这些复杂类型的值，我们只能使用内存复制的方法了。
- 函数的实现中使用了一个temp[size]数组

> 上述这些问题都增加了编程的复杂度

> 我们想交换两个字符串数组，类型是：char*，那么，我的swap()函数的x和y参数是不是要用void**了？这样一来，接口就没法定义了

**使用宏定义泛型**
```C
#define swap(x, y, size) {\
    char temp[size]; \
    memcpy(temp, &y, size); \
    memcpy(&y,   &x, size); \
    memcpy(&x, temp, size); \
}
```

> 用宏带来的问题就是编译器做字符串替换，因为宏是做字符串替换，所以会导致代码膨胀，导致编译出的执行文件比较大。不过对于 swap 这个简单的函数来说，用void*和宏替换来说都可以达到泛型

无论是用哪种方式，这种“泛型”是不是太宽松了一些，完全不做类型检查，就是在内存上对拷，直接操作内存的这种方式，感觉是不是比较危险，而且就像一个定时炸弹一样，不知道什么时候，在什么条件下就爆炸了。

无论哪种方式，接口都变得复杂了——加入了size，因为如果不加入size的话，那么我们的函数内部就需要自己检查size。然而，void* 这种地址的方式是没法得到size的。

而宏定义的那种方式，虽然不会把类型给隐藏掉，可以使用像 sizeof(x) 这样的方式得到 size。但是如果类型是 char*，那么，使用sizeof方式只能提到指针类型的size，而不是值的size。另外，对于不同的类型，比如说double和int，那应该用谁的size呢？是不是先转一下型呢？这些都是问题。

于是，这种泛型，让我们根本没有办法检查传入参数的size，导致我们只能增加接口复杂度，加入一个size参数，然后把这个问题抛给调用者了。


## 小结

如果说，程序 = 算法 + 数据，我觉得 C 语言会有这几个问题。

1. 一个通用的算法，需要对所处理的数据的数据类型进行适配。但在适配数据类型的过程中，C 语言只能使用 void* 或 宏替换的方式，这两种方式导致了类型过于宽松，并带来很多其它问题。
2. 适配数据类型，需要 C 语言在泛型中加入一个类型的 size，这是因为我们识别不了被泛型后的数据类型，而 C 语言没有运行时的类型识别，所以，只能将这个工作抛给调用泛型算法的程序员来做了。
3. 算法其实是在操作数据结构，而数据则是放到数据结构中的。所以，真正的泛型除了适配数据类型外，还要适配数据结构。最后这个事情导致泛型算法的复杂急剧上升。比如容器内存的分配和释放，不同的数据体可能有非常不一样的内存分配和释放模型，再比如对象之间的复制，要把它存进来我需要有一个复制，这其中又涉及到是深拷贝，还是浅拷贝。
4. 在实现泛型算法的时候，你会发现自己在纠结哪些东西应该抛给调用者处理，哪些又是可以封装起来。如何平衡和选择，并没有定论，也不好解决。

总体来说，C 语言设计目标是提供一种能以简易的方式编译、处理低层内存、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。C 语言也很适合搭配汇编语言来使用。C 语言把非常底层的控制权交给了程序员，它设计的理念是：
- 相信程序员；
- 不会阻止程序员做任何底层的事；
- 保持语言的最小和最简的特性；
- 保证 C 语言的最快的运行速度，那怕牺牲移值性。

从某种角度上来说，C 语言的伟大之处在于—— **使用 C 语言的程序员在高级语言的特性之上还能简单地做任何底层上的微观控制。** 这是 C 语言的强大和优雅之处。

不过，这只是在针对底层指令控制和过程式的编程方式。而对于更高阶更为抽象的编程模型来说，C 语言这种基于过程和底层的初衷设计方式就会成为它的短板。因为，在编程这个世界中，更多的编程工作是解决业务上的问题，而不是计算机的问题，所以，我们需要更为贴近业务更为抽象的语言。

那 C 语言本会怎么去解决这些问题呢？简单点说，C 语言并没有解决这些问题，所以才有了后面的 C++ 等其他语言

编程范式其实就是程序的指导思想，它也代表了这门语言的设计方向，我们并不能说哪种范式更为超前，只能说各有千秋。

比如 C 语言就是过程式的编程语言，像 C 语言这样的过程式编程语言优点是底层灵活而且高效，特别适合开发运行较快且对系统资源利用率要求较高的程序，但我上面抛出的问题它在后来也没有试图去解决，因为编程范式的选择基本已经决定了它的“命运”。
