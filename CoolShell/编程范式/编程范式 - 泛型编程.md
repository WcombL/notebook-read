# 编程范式 - 泛型编程

[原文](https://time.geekbang.org/column/article/303)

作为一门高级语言，C 语言绝对是编程语言历史发展中的一个重要里程碑，但随着认知的升级，面向过程的 C 语言已经无法满足更高层次的编程的需要。于是，C++ 出现了。

## C++ 语言

1980 年，AT&T 贝尔实验室的Bjarne Stroustrup创建的 C++ 语言横空出世，它既可以全面兼容 C 语言，又巧妙揉和了一些面向对象的编程理念。

推荐书籍: [C++ 语言的设计和演化],这本书系统介绍了 C++ 诞生的背景以及初衷，书的作者就是Stroustrup本人

C++ 很大程度就是来解决 C 语言中的各种问题和各种不方便。比如：
- 用引用来解决指针的问题。
- 用 namespace 来解决名字空间冲突的问题。
- 通过 try-catch 来解决检查返回值编程的问题。
- 用 class 来解决对象的创建、复制、销毁的问题，从而可以达到在结构体嵌套时可以深度复制的内存安全问题。
- 通过重载操作符来达到操作上的泛型。（比如用>>操作符消除printf()的数据类型不够泛型的问题。）
- 通过模板 template 和虚函数的多态以及运行时识别来达到更高层次的泛型和多态。
- 用 RAII、智能指针的方式，解决了 C 语言中因为需要释放资源而出现的那些非常 ugly 也很容易出错的代码的问题。
- 用 STL 解决了 C 语言中算法和数据结构的 N 多种坑。

## C++ 泛型编程

C++ 是支持编程范式最多的一门语言，它虽然解决了很多 C 语言的问题，但我个人觉得它最大的意义是解决了 C 语言泛型编程的问题。因为，我们可以看到一些 C++ 的标准规格说明书里面，有一半以上都在说明 STL 的标准规格应该是什么样的，这说明泛型编程是 C++ 重点中的重点。

理想情况下，算法应是和数据结构以及类型无关的，各种特殊的数据类型理应做好自己分内的工作。算法只关心一个标准的实现。**而对于泛型的抽象，我们需要回答的问题是，如果我们的数据类型符合通用算法，那么对数据类型的最小需求是什么？**

**C++ 是如何有效解决程序泛型问题的呢**
1. 它通过类的方式来解决。这样可以让一个用户自定义的数据类型和内建的那些数据类型就很一致
  - 类里面会有构造函数、析构函数表示这个类的分配和释放。
  - 还有它的拷贝构造函数，表示了对内存的复制。
  - 还有重载操作符，像我们要去比较大于、等于、不等于。
2. 通过模板达到类型和算法的妥协。模板很好地取代了 C 时代的宏定义带来的问题。
  - 模板有点像 DSL，模板的特化会根据使用者的类型在编译时期生成那个模板的代码。
  - 模板可以通过一个虚拟类型来做类型绑定，这样不会导致类型转换时的问题。
3. 通过虚函数和运行时类型识别。这样一来，就可以写出基于抽象接口的泛型。
  - 虚函数带来的多态在语义上可以让“同一类”的类型进行泛型。
  - 运行时类型识别技术可以做到在泛型时对具体类型的特殊处理。

一个良好的泛型编程需要解决如下几个泛型编程的问题：
- 算法的泛型；
- 类型的泛型；
- 数据结构（数据容器）的泛型。

## C++ 泛型编程的重要技术 - 迭代器

- 首先，一个迭代器需要和一个容器在一起，因为里面是对这个容器的具体的代码实现。
- 它需要重载一些操作符，比如：取值操作*、成员操作->、比较操作==和!=，还有遍历操作++，等等。
- 然后，还要typedef一些类型，比如value_type，告诉我们容器内的数据的实际类型是什么样子。
- 还有一些，如begin()和end()的基本操作。
- 我们还可以看到其中有一个pointer _ptr的内部指针来指向当前的数据（注意，pointer就是 T*）。

整个 STL 的泛型方法，其中包括：
- 泛型的数据容器；
- 泛型数据容器的迭代器；
- 然后泛型的算法就很容易写了。

## 需要更多的抽象

**更为复杂的需求**
比如：如果我们有这样的一个数据结构 Employee，里面有 vacation 就是休假多少天，以及工资。

```C
struct Employee {
    string name;
    string id;
    int vacation;
    double salary；
};
```
现在我想计算员工的总薪水，或是总休假天数。
```c
vector<Employee> staff;
//total salary or total vacation days?
sum(staff.begin(), staff.end(), 0);
```
我们的sum完全不知道怎么搞了，因为要累加的是Employee类中的不同字段，即便我们的 Employee 中重载了+操作，也不知道要加哪个字段。

那么面对这么多的需求，我们是否可以泛型一些呢？怎样解决这些问题呢？

**更高维度的抽象**
要解决这个问题，我希望我的这个算法只管遍历，具体要干什么，那是业务逻辑，由外面的调用方来定义我就好了，和我无关。这样一来，代码的重用度就更高了。
```C
template<class Iter, class T, class Op>
T reduce (Iter start, Iter end, T init, Op op) {
    T result = init;
    while ( start != end ) {
        result = op( result, *start );
        start++;
    }
    return result;
}
```
使用
```C
double sum_salaries =
  reduce( staff.begin(), staff.end(), 0.0,
          [](double s, Employee e)
            {return s + e.salary;}  );

double max_salary =
  reduce( staff.begin(), staff.end(), 0.0,
          [](double s, Employee e)
            {return s > e.salary? s: e.salary; } );
```
> 这里用了 C++ 的 lambda 表达式。

你可以很清楚地看到，reduce 这个函数就更通用了，具体要干什么样的事情呢？放在匿名函数里面，它会定义我，我只做一个 reduce。更抽象地来说，我就把一个数组，一个集合，变成一个值。怎么变成一个值呢？由这个函数来决定。
