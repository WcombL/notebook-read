# 编程范式 - 编程的本质

[原文](https://time.geekbang.org/column/article/2751)

> 如果将 Logic 和 Control 部分有效地分开，那么代码就会变得更容易改进和维护。

## 编程的本质

- Programs = Algorithms + Data Structures
- Algorithm = Logic + Control

第一个表达式倾向于数据结构和算法，它是想把这两个拆分，早期都在走这条路。他们认为，如果数据结构设计得好，算法也会变得简单，而且一个好的通用的算法应该可以用在不同的数据结构上。

第二个表达式则想表达，数据结构不复杂，复杂的是算法，也就是我们的业务逻辑是复杂的。我们的算法由两个逻辑组成，一个是真正的业务逻辑，另外一种是控制逻辑。程序中有两种代码，一种是真正的业务逻辑代码，另一种代码是控制我们程序的代码，叫控制代码，这根本不是业务逻辑，业务逻辑不关心这个事情。

> Program = Logic + Control + Data Structure

前面讲了这么多的编程范式，或是程序设计的方法。其实，我们都是在围绕着这三件事来做的。比如：

- 就像函数式编程中的 Map/Reduce/Filter，它们都是一种控制。而传给这些控制模块的那个 lambda 表达式才是我们要解决的问题的逻辑，它们共同组成了一个算法。最后，我再把数据放在数据结构里进行处理，最终就成为了我们的程序。
- 就像我们 Go 语言的委托模式的那个 Undo 示例一样。Undo 这个事是我们想要解决的问题，是 Logic，但是 Undo 的流程是控制。
- 就像我们面向对象中依赖于接口而不是实现一样，接口是对逻辑的抽象，真正的逻辑放在不同的具现类中，通过多态或是依赖注入这样的控制来完成对数据在不同情况下的不同处理。


- Control 是可以标准化的。比如：遍历数据、查找数据、多线程、并发、异步等，都是可以标准化的。
- 因为 Control 需要处理数据，所以标准化 Control，需要标准化 Data Structure，我们可以通过泛型编程来解决这个事。
- 而 Control 还要处理用户的业务逻辑，即 Logic。所以，我们可以通过标准化接口 / 协议来实现，我们的 Control 模式可以适配于任何的 Logic。

上述三点，就是编程范式的本质。
> **有效地分离 Logic、Control 和 Data 是写出好程序的关键所在！**

## 小结
代码复杂度的原因：
- 业务逻辑的复杂度决定了代码的复杂度；
- 控制逻辑的复杂度 + 业务逻辑的复杂度 ==> 程序代码的混乱不堪；
- 绝大多数程序复杂混乱的根本原因：业务逻辑与控制逻辑的耦合。

如何分离 control 和 logic 呢？我们可以使用下面的这些技术来解耦。
- State Machine
  - 状态定义
  - 状态变迁条件
  - 状态的 action
- DSL – Domain Specific Language
  - HTML，SQL，Unix Shell Script，AWK，正则表达式……
- 编程范式
  - 面向对象：委托、策略、桥接、修饰、IoC/DIP、MVC……
  - 函数式编程：修饰、管道、拼装
  - 逻辑推导式编程：Prolog

这就是编程的本质：
- Logic 部分才是真正有意义的（What）
- Control 部分只是影响 Logic 部分的效率（How）
