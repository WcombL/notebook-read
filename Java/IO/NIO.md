# NIO

有两种场景会用到IO：
- 文件IO
- 网络IO

> nio的优势在于网络IO

## IO与NIO的区别

IO是面向流的处理，NIO是面向块(缓冲区)的处理

- 面向流的I/O 系统一次一个字节地处理数据。
- 一个面向块(缓冲区)的I/O系统以块的形式处理数据。

## nio 组件

- buffer缓冲区
- Channel管道
- Selector选择器

Channel 不与数据打交道只负责传输数据
Buffer 负责与数据打交道

### Buffer

在NIO中负责数据的存取。缓冲区就是数组。用于存储不同数据类型的数据

根据数据类型不同，提供相应的缓冲区：
- ByteBuffer
- CharBuffer
- ShortBuffer
- IntBuffer
- LongBuffer
- FloatBuffer
- DoubleBuffer

上述缓冲区的管理方式几乎一致，通过allocate()获取缓冲区。

读取缓冲区数据和写数据到缓冲区(get()、put())

Buffer维护4个核心属性，以提供包含数组的信息

- 容量Capacity
    缓冲区能够容纳的数据元素的最大数量。容量在缓冲区创建时被设定，并且永远不会改变(因为底层使用的是数组)
- 上界Limit
  缓冲区里的数据总数，代表当前缓冲区一共有多少数据
- 位置Position
  下一个要被读或写的元素位置。Position会自动由相应的get()和put()函数更新
- 标记Mark
  一个备忘位置。用于记录上一次读写的位置。可以通过reset()恢复到mark位置

缓冲区数据的核心方法：
- put(): 存入数据到缓冲区
- flip(): 切换成读模式
- get(): 获取缓冲区的数据
- clear(): 清空缓冲区，并使缓冲区可写


### Channel 管道

管道：用于源节点与目标节点的连接。在NIO中负责缓冲区数据传输。Channel 本身不存储数据，因此需要配合缓冲区进行传输

主要实现类：
- FileChannel
- SocketChannel
- ServerSocketChannel
- DatagramChannel

获取管道：
- getChannel(): 流
- 各类管道的静态方法open()
- Files工具类的newByteChannel()
- transfer(): 数据传输(直接操作缓冲区)

#### 直接与非直接缓冲区

- 非直接缓冲区是需要经过一个copy的阶段(从内核空间copy到用户空间)
- 直接缓冲区不需要经过copy阶段，也可以理解成内存映射文件


## IO模型

阻塞I/O模型

### 阻塞I/O模型

默认情况下所有操作都是阻塞的

在进程空间中调用recvform,其系统调用直到数据包到达且被复制到应用进程的缓冲区中或者发生错误时才返回，在此期间一直等待

进程在调用recvform开始到它返回的整段时间内都是被阻塞的，所有叫阻塞I/O模型

### 非阻塞I/O模型

recvform从应用层到内核的时候，就直接返回一个EWOULDBLOCK错误，一般都对非阻塞I/O模型进行轮询检查这个状态，看内核是不是有数据到来

### I/O复用模型

file descriptor（fd，文件描述符）

Linux提供select/poll，进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪状态。
select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到了一些限制。

Linux还提供一个epoll系统调用，epoll使用基于事件驱动方式代替顺序扫描，因此性能更高。当有fd就绪时，立即调用函数rollback。

### 信号驱动I/O模型

首先开启套接口信号驱动I/O功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回，进程继续工作，非阻塞）。当数据准备就绪时，就为改进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环函数处理。

### 异步I/O

告知内核启动某个操作，并让内核在整个操作完成后（包括数据的复制）通知进程。

信号驱动I/O模型通知的是何时可以开始一个I/O操作，异步I/O模型有内核通知I/O操作何时已经完成

## I/O多路复用技术

I/O编程中，需要处理多个客户端接入请求时，可以利用多线程或者I/O多路复用技术进行处理。

I/O多路复用技术通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。

与传统的多线程模型相比，I/O多路复用的最大优势就是系统开销小，系统不需要创建新的额外线程，也不需要维护这些线程的运行，降低了系统的维护工作量，节省了系统资源

应用场景：
- 服务器需要同时处理多个处于监听状态或多个连接状态的套接字。
- 服务器需要同时处理多种网络协议的套接字。

支持I/O多路复用的系统调用主要有select、pselect、poll、epoll

而当前推荐使用的是epoll，优势如下：
- 支持一个进程打开的socket fd不受限制。
- I/O效率不会随着fd数目的增加而线性下将。
- 使用mmap加速内核与用户空间的消息传递。
- epoll拥有更加简单的API。
